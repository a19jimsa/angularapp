#version 300 es
precision mediump float;

in vec2 v_texcoord;
in float v_height;

in vec3 v_normal;
in float v_depth;
in float v_fogDistance;
in vec4 v_worldSpace;
in vec3 v_cameraPos;
in vec3 v_fragPos;

out vec4 FragColor;

uniform sampler2D u_texture;
uniform sampler2D u_splatmap;

uniform float u_fogPower;
uniform float u_tiling;
uniform vec3 u_cameraPos;

struct Material{
   vec3 ambient;
   vec3 diffuse;
   vec3 specular;
   float shininess;
};

uniform Material material;

struct Light{
   vec3 position;

   vec3 ambient;
   vec3 diffuse;
   vec3 specular;
};

uniform Light light;


vec4 TriplarMapping(vec4 worldPosition, vec3 worldNormal, sampler2D bajs, vec2 tile){
   vec2 pixelResolution = vec2(6144, 2048);
   vec2 pixelOffset = 1.0 / pixelResolution;
   vec2 padding = pixelOffset * 0.5;
   vec2 tileSize = vec2(1.0 / 6.0, 1.0 / 2.0);
   float tiling = u_tiling;

   vec3 blending = abs(worldNormal);

   blending = pow(blending, vec3(64.0));

   blending /= (blending.x + blending.y + blending.z);

   vec2 uvX = worldPosition.zy * tiling;
   vec2 uvY = worldPosition.xz * tiling;
   vec2 uvZ = -worldPosition.xy * tiling;

   vec4 colorX = texture(bajs, fract(uvX) * (tileSize - 2.0 * padding) + tile * tileSize + padding);
   vec4 colorY = texture(bajs, fract(uvY) * (tileSize - 2.0 * padding) + tile * tileSize + padding);
   vec4 colorZ = texture(bajs, fract(uvZ) * (tileSize - 2.0 * padding) + tile * tileSize + padding);

   vec4 finalColor = colorX * blending.x + colorY * blending.y + colorZ * blending.z;
   return finalColor;
}

void main() {

    // ambient
    vec3 ambient = light.ambient * material.ambient;
  	
    // diffuse 
    vec3 norm = normalize(v_normal);
    vec3 lightDir = normalize(light.position - v_fragPos);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    
    // specular
    vec3 viewDir = normalize(v_cameraPos - v_fragPos);
    vec3 reflectDir = reflect(-lightDir, norm);  
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    vec3 specular = light.specular * (spec * material.specular);  

   vec4 leaf_color = TriplarMapping(v_worldSpace, norm, u_texture, vec2(0.0, 0.0));
   vec4 sand_color = TriplarMapping(v_worldSpace, norm, u_texture, vec2(3.0, 0.0));
   vec4 snow_color = TriplarMapping(v_worldSpace, norm, u_texture, vec2(3.0, 1.0));
   vec4 ground_color = TriplarMapping(v_worldSpace, norm, u_texture, vec2(5.0, 1.0));

   vec4 splat = texture(u_splatmap, v_texcoord);

   vec4 splatColor =
      leaf_color * splat.r +
      sand_color  * splat.g +
      snow_color  * splat.b +
      ground_color * splat.a;

   float fogFactor = 1.0 - exp(- (v_fogDistance * u_fogPower) * (v_fogDistance * u_fogPower));
   //float fogFactor = 1.0 - exp(-v_fogDistance * u_fogPower);
   //float heightFactor = 1.0 - smoothstep(0.0, 100.0, v_height);
   //fogFactor *= heightFactor;
   fogFactor *= 0.6;

   vec3 fogColor = vec3(0.5, 0.5, 0.5);
   vec3 color = mix(splatColor.rgb, fogColor, fogFactor);

   vec3 result = (ambient + diffuse + specular) * color;
   FragColor = vec4(result, 1.0);
   //gl_FragColor = vec4(1.0);
   //gl_FragColor = vec4(normalize(v_worldNormal), 1.0);
}