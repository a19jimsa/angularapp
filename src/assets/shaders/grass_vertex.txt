#version 300 es
precision mediump float;
layout(location = 0) in vec3 a_position;
layout(location = 1) in vec2 a_texcoord;
layout(location = 2) in vec3 a_normal;
layout(location = 3) in vec3 a_offset;

uniform mat4 u_matrix;

float hash(float n) {
    return fract(sin(n) * 43758.5453123);
}

vec3 rotateX(float angle, vec3 pos){
    float c = cos(angle);
    float s = sin(angle);

    // Rotera kring Y-axeln (normals riktning ändras också)
    return vec3(
        pos.x * c - pos.z * s,
        pos.y,
        pos.x * s + pos.z * c
    );
}

vec3 rotateZ(float angle, vec3 pos){
    float c = cos(angle);
    float s = sin(angle);

    // Rotera kring Y-axeln (normals riktning ändras också)
    
    return vec3(
        pos.x * c - pos.y * s,
        pos.x * s + pos.y * c,
        pos.z
    );
}

void main() {
    //v_random_Id = hash(float(gl_InstanceID)) * 6.28318530718;
    //float noise = texture(u_texture, offset.xz * 0.1).r;
    //float sway = sin(u_time * 0.2 + (offset.x + noise) * 0.1);
    //vec3 displaced = a_position;
    //v_height = a_position.y;
    // Slumpa en vinkel mellan 0 och 2π
    //float angle = hash(float(gl_InstanceID)) * 6.28318530718;
    //vec3 rotatedPos = rotateX(angle, a_position);
    //float bendAmount = mix(0.0, 0.5, v_random_Id);
    //float bend = a_position.y * (0.2 + sway);
    //vec3 newPos = rotateZ(bend * 0.2, rotatedPos);
    //gl_Position = u_matrix * (vec4(newPos, 1.0) + vec4(offset, 1.0));
    gl_Position = u_matrix * vec4(a_position + a_offset, 1.0);
}
