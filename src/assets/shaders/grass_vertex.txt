precision mediump float;

attribute vec3 a_position;
attribute vec2 a_texcoord;
attribute vec3 a_normal;
attribute vec3 a_instancePositions;
attribute float a_instanceID;

uniform mat4 u_matrix;
uniform float u_time;
uniform sampler2D u_texture;

varying vec2 v_texcoord;
varying float v_height;
varying vec3 v_instancePositions;
varying float v_random_Id;

float hash(float n) {
    return fract(sin(n) * 43758.5453123);
}

vec3 rotateX(float angle, vec3 pos){
    float c = cos(angle);
    float s = sin(angle);

    // Rotera kring Y-axeln (normals riktning ändras också)
    return vec3(
        pos.x * c - pos.z * s,
        pos.y,
        pos.x * s + pos.z * c
    );
}

vec3 rotateZ(float angle, vec3 pos){
    float c = cos(angle);
    float s = sin(angle);

    // Rotera kring Y-axeln (normals riktning ändras också)
    
    return vec3(
        pos.x * c - pos.y * s,
        pos.x * s + pos.y * c,
        pos.z
    );
}

void main() {
    v_random_Id = hash(a_instanceID) * 6.28318530718;
    float noise = texture2D(u_texture, a_instancePositions.xz * 0.1).r;
    float sway = sin(u_time * 0.2 + (a_instancePositions.x + noise) * 0.1);
    vec3 displaced = a_position;
    v_height = a_position.y;
    v_texcoord = a_texcoord;
    v_instancePositions = a_instancePositions;
    // Slumpa en vinkel mellan 0 och 2π
    float angle = hash(a_instanceID) * 6.28318530718;
    vec3 rotatedPos = rotateX(angle, a_position);
    float bendAmount = mix(0.0, 0.5, v_random_Id);
    float bend = a_position.y * (0.2 + sway);
    vec3 newPos = rotateZ(bend * 0.2, rotatedPos);
    gl_Position = u_matrix * (vec4(newPos, 1.0) + vec4(a_instancePositions, 1.0));
}
