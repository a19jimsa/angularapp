#version 300 es
precision mediump float;
layout(location = 0) in vec3 a_position;
layout(location = 1) in vec2 a_texcoord;
layout(location = 2) in vec3 a_normal;
layout(location = 3) in vec3 a_offset; // Instance variable

out float v_random_Id;
out float v_height;
out vec3 v_normal;
out vec3 v_fragPos;

uniform mat4 u_matrix;
uniform float u_time;

float hash(float n) {
    return fract(sin(n) * 43758.5453123);
}

vec3 rotateX(float angle, vec3 pos){
    float c = cos(angle);
    float s = sin(angle);

    // Rotera kring Y-axeln (normals riktning ändras också)
    return vec3(
        pos.x * c - pos.z * s,
        pos.y,
        pos.x * s + pos.z * c
    );
}

vec3 rotateZ(float angle, vec3 pos){
    float c = cos(angle);
    float s = sin(angle);

    // Rotera kring Y-axeln (normals riktning ändras också)
    
    return vec3(
        pos.x * c - pos.y * s,
        pos.x * s + pos.y * c,
        pos.z
    );
}

void main() {
    v_random_Id = hash(float(gl_InstanceID)) * 6.28318530718;
    float sway = sin(u_time * 0.2 + (a_offset.x) * 0.1);
    v_height = a_position.y;
    // Slumpa en vinkel mellan 0 och 2π
    float angle = hash(float(gl_InstanceID)) * 6.28318530718;
    vec3 rotatedPos = rotateX(angle, a_position);
    float bendAmount = mix(0.0, 0.5, v_random_Id);
    float bend = a_position.y * (0.2 + sway);
    vec3 newPos = rotateZ(bend * 0.2, rotatedPos);
    vec3 rotatedNormal = rotateX(angle, a_normal);
    rotatedNormal = rotateZ(bend * 0.2, rotatedNormal);
    v_normal = normalize(rotatedNormal);
    v_fragPos = newPos + a_offset;
    gl_Position = u_matrix * vec4(newPos + a_offset, 1.0);
}
