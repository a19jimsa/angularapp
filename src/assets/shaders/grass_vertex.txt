precision mediump float;

attribute vec3 a_position;
attribute vec2 a_texcoord;
attribute vec3 a_normal;
attribute vec3 a_instancePositions;
attribute float a_instanceID;

uniform mat4 u_matrix;
uniform float u_time;
uniform sampler2D u_texture;

varying vec2 v_texcoord;
varying float v_height;
varying vec3 v_instancePositions;

float hash(float n) {
    return fract(sin(n) * 43758.5453123);
}

vec3 rotateX(float angle, vec3 pos){
    float c = cos(angle);
    float s = sin(angle);

    // Rotera kring Y-axeln (normals riktning ändras också)
    return vec3(
        pos.x * c - pos.z * s,
        pos.y,
        pos.x * s + pos.z * c
    );
}

void main() {
    float noise = texture2D(u_texture, a_instancePositions.xz * 0.1).r;
    float sway = sin(u_time * 0.1 + (a_instancePositions.x + noise) * 0.1);
    float swayz = sin(u_time * 0.1 + (a_instancePositions.z + noise) * 0.1);
    vec3 displaced = a_position;
    displaced.x += sway * (a_position.y / 2.0);
    displaced.z += swayz * (a_position.y / 2.0);
    v_height = a_position.y;
    v_texcoord = a_texcoord;
    v_instancePositions = a_instancePositions;
    // Slumpa en vinkel mellan 0 och 2π
    float angle = hash(a_instanceID) * 6.28318530718;
    vec3 rotatedPos = rotateX(angle, displaced);

    gl_Position = u_matrix * (vec4(rotatedPos, 1.0) + vec4(a_instancePositions, 1.0));
}
